みなさまお集まりいただき誠にありがとうございます！
本日は「ドメインモデリングとコードで理解する実践DDD入門」というテーマでお話ししてまいります！
どうぞよろしくお願いいたします！

## 本日の内容📗
今回お話しすることの概要についてお話しします。

- DDDとは
- なぜDDDなのか
- ドメインモデリングとは
- ドメインモデリングの結果をどうコードに落とすのか

## 自己紹介
次に改めて自己紹介させてください。

フロントエンド推進チームの平野 宇教といいます。
以前は支援開発チームで、IBJS, Leaf, smarry, kana, BN, IBRのタスクをさせていただいていました。
24歳です。今年で25になるのですがその話をすると必ず中村さんに「え、でも今年でアラサーだよね？？(爆笑)」と言われます。
DDDなどの設計やアーキテクチャに特に興味があります。
AIもいい加減にキャッチアップしたいです。cursorぐらいしか使わないので。

## DDDとっつきにくくない？
みなさんの中でDDDわかる人とか
触ったことがある人ってどれくらいいらっしゃいますか？

DDD触ったけどわからないというか、
専門用語が多すぎてとっつきにくいみたいな人いらっしゃいますか？

私がDDD学び始めて思ったのは、
- 専門用語が多すぎてわかりにくい
- ハンズオン的な教材が少ない
- DDDの雰囲気がなんとなくわかっても実際にどうやってコードに落とせばいいかわからない
ということです。

正直、DDDをしっかり理解するには一つ一つの用語についてある程度理解して
戦術的設計・戦略的設計の両方を理解する必要があるかと思います。

ですが今回は専門用語の説明はできるだけ簡単に要点だけ伝わる様にして、
なぜDDDなのか、DDDをするとどんな嬉しさがあるのか
をわかってもらって、
**「DDDおもしろそうじゃね？」**
**「DDDやったらこんないいことがあるんだ！」**
と思ってもらえる回にしたいと思ってます。

私自身ドメイン駆動設計を学び始めたのは３ヶ月前と最近なのですが、
DDDの学習・IBRや他の凝集度が低く可読性が低いコードで書かれたプロジェクトでのタスクを通して、
DDDの良さがわかったし、設計って大事だなって思いました。

ぜひ今後新しくプロジェクトが作られる時に
DDDのエッセンスを取り入れて欲しいし、
既存のプロジェクトでもDDDの考え方やデザインパターンや
アーキテクチャを用いて改善できると思っているのでぜひ今日は最後までお付き合いいただければと思います。

## このエンジニアゼミを終えたらできるようになること
「このエンジニアゼミを終えたらできるようになること」
についてお話しします。

このエンジニアゼミを聞くと、

- DDDの戦略的設計・戦術的設計の基礎がわかる
- DDDにおけるエンティティ・値オブジェクトとは何かわかる
- ドメインモデリングの手法がわかる
- ドメインモデル図をもとにしたドメインオブジェクトの実装方法がわかる


## 今回扱わないこと
今回扱わないことについてもお話しします。

- DDDで扱われるアーキテクチャの詳細な内容
- ドメイン層以外の実装について
- テストについて

以上の内容につきましては、今回は扱わないか、さらっと流すかくらいにします。
あくまでDDDとはどんなものなのか雰囲気を知っていただくのが目的ですので、
ドメイン層以外の実装は次回以降機会があればお話ししたいと思っています。


## もろたで
(もろたでドメイン駆動)
docs/script/imgs/morotadekudou1_R.jpegを表示
いっしょにDDDもろたでしていきましょう！

## DDDとは
ではさっそくDDDとは何かからお話ししていきます。

DDDとはソフトウェア設計手法の1つで、
「ドメインに存在する特定の問題を解決することにフォーカスした設計手法」と言えます。

ソフトウェアというのは何か問題を解決するために作られますが、
ソフトウェアで問題解決しようとする対象領域のことをドメインと呼びます。

例えばSNSなら、投稿・フォロー・通知とかのドメインがあります。

## DDDのアプローチ
DDDでは問題解決のために以下のアプローチを取ります。

（ドメインについての理解を深めモデルを継続的に改善する。）
(モデルを継続的にソフトウェアに反映する。)


## DDDが向いているソフトウェア
複雑なドメインを持つものは基本的にDDDは向いていると思います。
はまっち曰く6割くらいのソフトウェアはDDDでやれば大体うまくいく、らしいです。


## DDDが向いていないもの
- 簡単なCRUD処理しかないもの(ただのTodoアプリなど)
- ソフトウェアの価値が技術的な複雑さにあるもの(プログラミング言語、コンパイラ、ストレージなど)

は向いていないと言えるかなと思います。

## DDDのメリット・デメリット

メリット

- 保守性と機能性の向上
- 役に立つソフトウェアを作れる
- コードのドキュメント化

デメリット

- 比較的学習コストが高い
- MVCなどに比べ開発初期の開発スピードが劣る
- モデリングとかをしっかりやると労力がかかる。


## トランザクションスクリプトとレイヤードアーキテクチャの比較
DDDというよりアーキテクチャの話に近くなるのですが、
トランザクションスクリプトでは時間が経つほど保守しにくくなるのですが、
レイヤ化アーキテクチャでは長い間保守しやすい状態が保たれるというのがわかると思います。


## なぜDDDなのか
次になぜDDDなのかということをお話しします。

## DDDの目的
なぜDDDなのか、要するにDDDをやるとどんな良いことがあるのか、こういう場面でDDDは特に効力を発揮しますよというお話しをそれぞれやっていきます。

なぜDDDなのか、DDDやる理由というか目的なんですけど、大きく以下の2つがあります。

ソフトウェアの
- 機能性
- 保守性

を高めること。

機能性というのは、「ソフトウェアによる問題解決能力、ユーザーの要求を満たす力」のことを指します。

## DDDのサイクル
DDDではドメインモデリングを行い、コードに落とし、何か改善点があれば再度ドメインモデリングをしてまたコードに落とすというサイクルを回していきます。

これによってしっかり仕様どおりに動作するアプリケーションを開発して、
作ったけど使えないという事態を避けることにつながります。






## ドメインモデリングとは
それではドメインモデリングについてお話ししていきます。

ドメインモデリングとは、ドメインモデルを作る作業です。

で、ドメインモデルがなんなのかですが、
📘 出典：Eric Evans『Domain-Driven Design』にはこう記載されています。

*“A model is a system of abstractions that describes selected aspects of a domain and can be used to solve problems related to that domain.”*

（モデルとは、ドメインの特定の側面を抽象化したものであり、そのドメインに関する問題を解決するために使われる。）
です。

例としてメモアプリを考えます。
現実のメモにはメモの内容だけでなく筆跡とか字の大きさとかメモの材質とかがそもそもありますが、ソフトウェアには必要ないし無理(できそうだが)
ソフトウェアで問題と解決するのに必要な情報だけを抽出します。
例えばメモとしてはメモの内容だけあればソフトウェアでは十分ですね。
仮に手書きのメモ機能が欲しいなら手書きできる様にするとかはありだと思います。

こういうふうに、ソフトウェアとして解決したい課題について必要な側面だけを現実の事象から抽出することがドメインモデリングと言います。

ドメインモデリングを行う上で大事なのは、
最初から完璧なものを作ろうとしないことです。
モデリングした結果というのは、
実際にコードに落としてみて動かすまでその良し悪しというのはわからないというか、
完璧なものを作るのは難しいです。
実装して初めて気づくこともあるので、
モデリング→実装→フィードバック→モデリング…というサイクルを周してよりよいものを作るというのが前提だということを把握しておきましょう。


## マッチングアプリのモデリングを行う。
ではモデリングを行なっていきます。
ここではマッチングアプリを題材にして実際にドメインモデリングを行いたいと思います。

モデリングの手法は様々あります。

簡単なものだと、
ユースケースを洗い出して、ユースケース図を作成する。
その後にドメインモデル図を作成する。
というような流れだったり、他にオブジェクト図というものやシステム関連図も作るというのがあります。

今回はsudoモデリングという、
モデリング手法を用いようと思っていたし
これ結構良さそうだなと思ったので一旦解説します。、

sudoモデリングでは、
- system-relation-diagram
- usecase-diagram
- domain-model-diagram
- object-diagram

(それぞれ説明する)

オブジェクト図ですが、
今回モデリングするマッチングアプリに関しては、
話をわかりやすくするために実際のマッチングアプリよりだいぶ機能を削っている
（最低限のもの）というのと、オブジェクト図にするまでもなく男性と女性でお互いにいいねしたらマッチングしてメッセージが送れる！っていうそれしかないので、

ユースケース図・ドメインモデル図・システム関連図の3つで行いたいと思います。
まあこれあればわかると思うので。


ドメインモデリングは本来であれば
ドメインエキスパートとともに行います。
ドメインエキスパートとは、
そのドメインに詳しい人のことを指します。

たとえば経費生産システムだったら経理部の人がドメインエキスパートになります。

なんですけど、今回は別にそういう人はいないので
ChatGPTをドメインエキスパートとしてユースケースとかを考えてもらいました。

システム関連図は自分で作成しました。
システム関連図を作るには「これは誰が使うシステムなのか？」という問いに対して答えを出す必要があります。

そのためユースケースとかドメインモデル図を作る前に作成した方がやりやすいのではないかと思います。

次にユースケースですが、
こちらになります。

次にドメインモデル図ですが以下の様になっています。
特筆すべきところはそんなにないんですが、
さっき行った集約について、
例えばメッセージを送ったらトークルーム自体も更新されるので、
そう言った整合性を意識して作成しました。




## ドメインモデリングの結果をコードに落とす。
それではドメインモデリングの結果を実際のコードに落としていきたいと思います。
今回扱う技術についてお話しします。

## 言語
言語はおそらくIBJのエンジニアが最もとっつきやすいであろうRuby, Railsを採用しました。
ただしDDDを行う上ではRubyは向いてはいない言語なのかなと思います。

理由としてはRubyが動的言語であるかつインターフェースがないので、
周知されていないとせっかく制約を表現してもそれを破れてしまうからです。
タイプヒントと静的解析である程度補完できるのかなと思います。

JavaやGo, TSなどの静的かつインターフェースがある言語、
動的言語ならPHPとかがいいかなと思います。

## アーキテクチャ
次にアーキテクチャです。
アーキテクチャは今回オニオンアーキテクチャを使用します。

よくこの丸い図が用いられるんですが分かりにくいので次のスライドのこれを使います。

オニオンアーキテクチャは、
ドメイン層、インフラ層、ユースケース層、プレゼンテーション層の4つの層に役割を分けて、
ドメイン層はどこにも依存しないようにするアーキテクチャです。

オニオンアーキテクチャはドメイン層が変更されることによって他の層に影響が及ぶ、まさにドメインに駆動するアーキテクチャのためDDDでよく用いられます。

各層の説明をしていくと、
Presentation層っていうのがリクエストの受け取りやレスポンスの返却、
リクエストのバリデーションを行う層になります。
Handlerって言ったりControllerと言ったりあとはディレクトリ名をそうしたりもしますが
大体同じものです。
MVCのControllerと同じ様なものだと思ってもらえればいいかなと思います。

でユースケースを説明する前に
ドメイン・インフラの説明をします。

ドメイン層というのがここまでにモデリングしてきたドメインオブジェクトを記載する層です。
ここでドメインの制約とかドメイン層の知識を記載していきます。
この層だけは他の層には絶対に依存しません。
他の層の実装に合わせてドメイン層が変わるということがないということです。

次にインフラ層です。
いわゆる技術層と言われるのですが、
DBやファイルとのやりとりとか永続化とか、外部APIとのやりとりなどをここで担います。

次にアプリケーション層です。
ここにUseCaseを記載していきます、UseCaseっていうのは「何をするか」というのを表現するところです。
例えばユーザーを作成する、とかツイート一覧を取得する。とかです。
ここでドメイン層とかインフラ層のオブジェクトを使ってユースケースを組み立てます。
アプリケーションだと「結局何をするのか」が分かりにくいので
UseCaseという名前でディレクトリを作ることのほうが多い気がします。

## デザインパターン
## 完全コンストラクタパターン
次にデザインパターンについてもお話しします。

DDDではドメインオブジェクトの実装に完全コンストラクタパターンを使用します。

完全コンストラクタパターンとは、
インスタンス化する際に初期化されていない値の代入を防ぎ、
インスタンス化した時点でオブジェクトが完全な状態であることを担保するデザインパターンを指します。
さらに、setterは用意せず、状態を変化させるための特別なミューテーションのメソッドを用意し、
一度インスタンス化されたらミューテーションのメソッドを介さないと状態を変化できない様に強制します。

# 初期化されていない値がある状態で後でsetterで値を入れている実装例を示したい✅
## 完全コンストラクタパターンを用いない例
完全コンストラクタパターンを用いない場合のコードを書いてみました。
様々な問題があるのですが、
これだと必要なパラメータが渡っていない状態で初期化できたり、
あとから勝手にパラメータを変更できたりしてしまいます。

こうなると、ドメインを正しく表現できていなかったり、
不正な値を自由に設定できてしまいます。

こう言った問題を防ぐために完全コンストラクタパターンを用いて、
ドメインオブジェクトであるエンティティ・値オブジェクトを実装します。


## エンティティとは
同一判定を識別子で行うもの。
先ほど示したupdate_profileのようなミューテーションメソッドを記載すれば可変になり得ます。
不変としても良い。

わかりやすい例を示すと、
ここに〇〇さんがいますね？
この世に仮に名前も生年月日も顔も同じ〇〇さんがいたとしてもそれは別物として扱われます。
これがエンティティだと思ってください。
現実世界ではこれをたぶん戸籍とかDNAとかなんかで判定しますが、
エンティティはこれを識別子、IDで判定します。


## 値オブジェクトとは
同一判定を保持する値で行うもの。絶対に不変。
所持金を表すとき、10円玉を2つ持っている際にその10円玉はおなじ10円と見なすことができます。
（これが令和〇〇年と平成〇〇年のものと区別する様なコインコレクター用アプリでない限りは）
このように持っている属性が同じなら同一のものとみなせるものを値オブジェクトまたはバリューオブジェクトといいます。


## ディレクトリ構成
ディレクトリ構成については、
app/domainディレクトリをドメイン層として、
この配下にmodelsディレクトリを作成してドメインオブジェクトを作成していきます。

また、ActiveRecordのファイルが保存されている既存のmodelsディレクトリは使用しない。
集約単位での整合性とか永続化の表現が難しくなるからです。

それでは実際に実装していきます、というかもう書いてきたのでそれを見ながら解説していければと思います。



## 引用・参考資料
https://www.domainlanguage.com/ddd/
https://little-hands.hatenablog.com/entry/2018/12/10/ddd-architecture
https://little-hands.hatenablog.com/entry/2018/10/08/goal-of-ddd
https://little-hands.hatenablog.com/entry/2022/06/01/ddd-modeling